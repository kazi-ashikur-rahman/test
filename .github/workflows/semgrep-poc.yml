name: Semgrep PR Scan on Changed Lines
permissions:
  pull-requests: write
  contents: read
on:
  pull_request:
    branches:
      - main
      - stg
      - dev
jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ensures full history
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      
      - name: Install Semgrep
        run: python -m pip install --upgrade pip semgrep
      
      - name: Get changed files and lines
        id: changes
        run: |
          BASE_BRANCH=${{ github.event.pull_request.base.ref }}
          echo "Base branch: $BASE_BRANCH"
          
          # Fetch base branch
          git fetch origin $BASE_BRANCH
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only origin/$BASE_BRANCH...HEAD | grep -E '\.(js|jsx|ts|tsx|py|java|go|php|rb|c|cpp|cs|kt|swift)$' || true)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Export for next step
          echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
          echo "$CHANGED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "BASE_BRANCH=$BASE_BRANCH" >> $GITHUB_ENV
      
      - name: Run Semgrep on changed lines only
        run: |
          echo "Changed files to scan: $CHANGED_FILES"
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "‚úÖ No changed files. Skipping Semgrep."
            echo '{"results":[]}' > semgrep-report.json
          else
            echo "üîç Running Semgrep on changed lines only..."
            
            # Use semgrep's baseline functionality to scan only new/changed code
            # This scans the entire repo but reports only findings on changed lines
            semgrep --config auto --json --baseline-ref origin/$BASE_BRANCH --output semgrep-report.json .
            
            # Alternative: Manual line filtering (more precise but complex)
            # Uncomment below if you need even more precise line-level filtering
            
            # Create a script to filter results to changed lines only
            # python3 - <<'FILTER_SCRIPT'
            # import json
            # import subprocess
            # import re
            # 
            # # Get the diff with line numbers
            # diff_output = subprocess.run(['git', 'diff', '--unified=0', 'origin/${{ env.BASE_BRANCH }}...HEAD'], 
            #                            capture_output=True, text=True).stdout
            # 
            # # Parse changed line ranges for each file
            # changed_lines = {}
            # current_file = None
            # 
            # for line in diff_output.split('\n'):
            #     if line.startswith('+++'):
            #         current_file = line[6:] if line.startswith('+++ b/') else line[4:]
            #         changed_lines[current_file] = []
            #     elif line.startswith('@@'):
            #         # Parse hunk header: @@ -old_start,old_count +new_start,new_count @@
            #         match = re.search(r'\+(\d+)(?:,(\d+))?', line)
            #         if match and current_file:
            #             start_line = int(match.group(1))
            #             count = int(match.group(2)) if match.group(2) else 1
            #             changed_lines[current_file].extend(range(start_line, start_line + count))
            # 
            # # Load semgrep results and filter
            # try:
            #     with open('semgrep-report.json', 'r') as f:
            #         report = json.load(f)
            # except:
            #     report = {"results": []}
            # 
            # filtered_results = []
            # for result in report.get('results', []):
            #     file_path = result.get('path', '')
            #     start_line = result.get('start', {}).get('line', 0)
            #     
            #     # Check if this finding is on a changed line
            #     if file_path in changed_lines and start_line in changed_lines[file_path]:
            #         filtered_results.append(result)
            # 
            # # Save filtered results
            # filtered_report = {"results": filtered_results}
            # with open('semgrep-report.json', 'w') as f:
            #     json.dump(filtered_report, f, indent=2)
            # 
            # print(f"Filtered to {len(filtered_results)} findings on changed lines")
            # FILTER_SCRIPT
            
          fi
      
      - name: Build Markdown summary
        if: always()
        run: |
          python - <<'PY'
          import json
          import os
          
          try:
              with open('semgrep-report.json', 'r') as f:
                  report = json.load(f)
          except Exception as e:
              with open('semgrep_report.md', 'w') as f:
                  f.write(f"‚ùó Failed to read semgrep output: {e}")
              raise
          
          results = report.get('results', []) or []
          
          if not results:
              md = "‚úÖ **Semgrep:** No security issues found in changed lines."
          else:
              md = f"üö® **Semgrep Scan** found **{len(results)}** issue(s) in changed lines\n\n"
              counts = {}
              lines = []
              max_show = 40
              
              for i, r in enumerate(results):
                  if i >= max_show: 
                      break
                  
                  rule = r.get('check_id') or r.get('rule_id') or r.get('rule') or 'unknown'
                  msg = r.get('extra', {}).get('message') or r.get('message', '').strip()
                  path = r.get('path') or r.get('start', {}).get('path') or 'unknown'
                  line = r.get('start', {}).get('line') or ''
                  severity = (r.get('extra', {}).get('severity') or r.get('severity') or 'INFO').upper()
                  
                  counts[severity] = counts.get(severity, 0) + 1
                  
                  # Format with better styling
                  severity_emoji = {
                      'ERROR': 'üî¥', 'HIGH': 'üî¥',
                      'WARNING': 'üü°', 'MEDIUM': 'üü°', 
                      'INFO': 'üîµ', 'LOW': 'üîµ'
                  }.get(severity, '‚ö™')
                  
                  lines.append(f"{severity_emoji} **{severity}** `{rule}` ‚Äî {msg}  \n   üìÅ `{path}:{line}`")
              
              if counts:
                  md += "**Severity breakdown:**\n"
                  for severity in ['ERROR', 'HIGH', 'WARNING', 'MEDIUM', 'INFO', 'LOW']:
                      if severity in counts:
                          emoji = {'ERROR': 'üî¥', 'HIGH': 'üî¥', 'WARNING': 'üü°', 'MEDIUM': 'üü°', 'INFO': 'üîµ', 'LOW': 'üîµ'}.get(severity, '‚ö™')
                          md += f"- {emoji} {severity}: {counts[severity]}\n"
                  md += "\n**Issues found:**\n"
              
              md += "\n".join(lines)
              
              if len(results) > max_show:
                  md += f"\n\n_Showing first {max_show} of {len(results)} findings._"
                  
              md += f"\n\nüí° **Note:** Only showing issues in lines you modified/added in this PR."
          
          with open('semgrep_report.md', 'w') as f:
              f.write(md)
          print(md)
          PY
      
      - name: Post PR comment
        if: always()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: semgrep_report.md
