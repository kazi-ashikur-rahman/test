name: Semgrep PR Scan on Changed Files

on:
  pull_request:
    branches:
      - main
      - stg
      - dev

permissions:
  pull-requests: write
  contents: read

jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Semgrep
        run: python -m pip install --upgrade pip semgrep

      - name: Get changed lines
        id: changes
        run: |
          BASE_BRANCH=${{ github.event.pull_request.base.ref }}
          echo "Base branch: $BASE_BRANCH"

          git fetch origin $BASE_BRANCH
          
          # Use git diff with --no-index to get line numbers, and also generate a simple diff
          git diff --unified=0 --ignore-space-change origin/$BASE_BRANCH...HEAD > changed.diff
          
          # Also generate changed files list
          git diff --name-only origin/$BASE_BRANCH...HEAD > changed_files.txt
          
          echo "Changed files:"
          cat changed_files.txt
          echo ""
          echo "Sample diff (first 50 lines):"
          head -n 50 changed.diff

      - name: Run Semgrep on all changed files
        run: |
          echo "🔍 Running Semgrep..."
          semgrep --config auto --json --output semgrep-report.json

      - name: Filter results to changed lines
        run: |
          python - <<'PY'
          import json, re

          # Load Semgrep results
          report = json.load(open('semgrep-report.json'))
          results = report.get('results', [])

          # Parse diff using a much simpler and more reliable approach
          diff_map = {}
          
          print("Parsing diff file for changed lines...")
          
          with open('changed.diff', 'r') as f:
              lines = f.readlines()
          
          print("Raw diff content (first 20 lines):")
          for i, line in enumerate(lines[:20]):
              print(f"  {i+1:2d}: {repr(line)}")
          print("")
          
          current_file = None
          
          for line in lines:
              line = line.rstrip('\n\r')
              
              # Track current file being processed
              if line.startswith('+++ b/'):
                  current_file = line[6:]  # Remove '+++ b/' prefix
                  if current_file not in diff_map:
                      diff_map[current_file] = set()
                  print(f"Processing file: {current_file}")
                  
              # Parse hunk headers to get line ranges
              # Format: @@ -old_start,old_count +new_start,new_count @@
              elif line.startswith('@@') and current_file is not None:
                  # Use regex to extract the +start,count part
                  import re
                  match = re.search(r'@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@', line)
                  if match:
                      start_line = int(match.group(1))
                      count = int(match.group(2)) if match.group(2) else 1
                      
                      # Add all lines in this range
                      end_line = start_line + count - 1
                      for line_num in range(start_line, start_line + count):
                          diff_map[current_file].add(line_num)
                      
                      print(f"  Found changed lines: {start_line} to {end_line} ({count} lines)")

          # Debug output
          print("\nFinal detected changed lines:")
          for file_path, line_set in diff_map.items():
              if line_set:
                  sorted_lines = sorted(line_set)
                  print(f"  {file_path}: {sorted_lines}")
                  if len(sorted_lines) > 1:
                      print(f"    Range: {min(sorted_lines)}-{max(sorted_lines)}")

          # Debug: Print detected changed lines
          print("\nDetected changed lines:")
          for file, lines in diff_map.items():
              if lines:
                  sorted_lines = sorted(lines)
                  print(f"  {file}: {sorted_lines}")
                  if len(sorted_lines) > 1:
                      print(f"    Range: {min(sorted_lines)}-{max(sorted_lines)}")

          # Filter results to only those in changed lines
          filtered = []
          print(f"\nFiltering {len(results)} Semgrep findings...")
          
          for r in results:
              path = r.get("path")
              start_line = r.get("start", {}).get("line")
              end_line = r.get("end", {}).get("line", start_line)
              
              if path in diff_map:
                  # Check if any line of the finding overlaps with changed lines
                  finding_lines = set(range(start_line, end_line + 1))
                  changed_lines = diff_map[path]
                  
                  if finding_lines & changed_lines:  # Set intersection
                      overlapping_lines = sorted(finding_lines & changed_lines)
                      print(f"  ✓ Keeping finding in {path}:{start_line}-{end_line} (overlaps with changed lines: {overlapping_lines})")
                      r['overlapping_changed_lines'] = overlapping_lines
                      filtered.append(r)
                  else:
                      print(f"  ✗ Skipping finding in {path}:{start_line}-{end_line} (no overlap with changed lines)")
              else:
                  print(f"  ✗ Skipping finding in {path} (file not in changed files)")

          report['results'] = filtered
          report['debug_info'] = {
              'total_original_findings': len(results),
              'filtered_findings': len(filtered),
              'changed_files': {k: sorted(v) for k, v in diff_map.items() if v}
          }
          
          json.dump(report, open('semgrep-report.json','w'), indent=2)
          print(f"\nFinal result: {len(filtered)} findings (from {len(results)} total)")
          PY

      - name: Build Markdown summary
        run: |
          python - <<'PY'
          import json
          try:
              report = json.load(open('semgrep-report.json'))
          except Exception as e:
              open('semgrep_report.md','w').write(f"❗ Failed to read semgrep output: {e}")
              raise

          results = report.get('results', []) or []
          debug_info = report.get('debug_info', {})
          
          if not results:
              md = "✅ **Semgrep:** No issues found in changed code lines.\n\n"
              if debug_info.get('total_original_findings', 0) > 0:
                  md += f"_Note: {debug_info['total_original_findings']} findings were found in changed files but not in the lines you modified._"
          else:
              md = f"🚨 **Semgrep Scan** found **{len(results)}** issue(s) in your changed code lines\n\n"
              
              # Show debug info
              if debug_info:
                  md += f"📊 **Scan Summary:**\n"
                  md += f"- Total findings in changed files: {debug_info.get('total_original_findings', 0)}\n"
                  md += f"- Findings in your modified lines: {len(results)}\n\n"
              
              # Show changed files and lines for transparency
              if debug_info.get('changed_files'):
                  md += f"📝 **Your Changes:**\n"
                  for file, lines in debug_info['changed_files'].items():
                      if lines:
                          line_ranges = []
                          if len(lines) == 1:
                              line_ranges.append(str(lines[0]))
                          else:
                              # Group consecutive lines into ranges
                              start = lines[0]
                              end = lines[0]
                              for line in lines[1:]:
                                  if line == end + 1:
                                      end = line
                                  else:
                                      if start == end:
                                          line_ranges.append(str(start))
                                      else:
                                          line_ranges.append(f"{start}-{end}")
                                      start = end = line
                              if start == end:
                                  line_ranges.append(str(start))
                              else:
                                  line_ranges.append(f"{start}-{end}")
                          
                          md += f"- `{file}`: lines {', '.join(line_ranges)}\n"
                  md += "\n"
              
              # Group findings by severity
              counts = {}
              lines = []
              for r in results:
                  rule = r.get('check_id') or r.get('rule_id') or 'unknown'
                  msg = r.get('extra', {}).get('message') or r.get('message','').strip()
                  path = r.get('path') or 'unknown'
                  line = r.get('start', {}).get('line') or ''
                  severity = (r.get('extra', {}).get('severity') or 'INFO').upper()
                  overlapping_lines = r.get('overlapping_changed_lines', [])
                  
                  counts[severity] = counts.get(severity,0)+1
                  
                  severity_emoji = "🔴" if severity == "ERROR" else "🟡" if severity == "WARNING" else "🔵"
                  overlap_info = f" (affects your lines: {', '.join(map(str, overlapping_lines))})" if overlapping_lines else ""
                  
                  lines.append(f"- {severity_emoji} **{severity}** `{rule}` — {msg}  \n  📍 `{path}:{line}`{overlap_info}")

              md += "**Severity Breakdown:**\n" + "\n".join([f"- {k}: {v}" for k,v in counts.items()]) + "\n\n"
              md += "**Issues Found:**\n" + "\n".join(lines)
              md += "\n\n💡 **Please review and fix these issues in your changed code before merging.**"

          open('semgrep_report.md','w').write(md)
          print(md)
          PY

      - name: Post PR comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: semgrep_report.md
